package com.example.demos;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
// 해당 클래스에 SpringBoot를 설정 및 해당 클래스가 있는 패키지를 베이스 패키지로 설정.
// 스프링의 주요 기능 중 하나가 의존성 주입 컨테이너로서의 기능이며, 이러한 컨테이너 오브젝트인 ApplicationContext에
// 빈을 등록하거나, 찾아서 주입할수 있게 한다.

// @Bean - 메소드 레벨에서 선언하여, 반환되는 인스턴스를 수동으로 Bean으로 등록시킴 (직접적으로 스프링에서 Bean을 관리하기 위함)
// @Component - 클래스 레벨에서 선언하여, @ComponentScan을 통하여 자동으로 Bean을 찾고 등록시킴.
public class DemosApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemosApplication.class, args);
    }
}

// * 레이어드 아키텍쳐 패턴 - 웹 어플리케이션 등에서 MVC 모델과 함께 사용되는 패턴. 하위 레이어가 제공하는 기능을 상위 레이어가 이용함으로써, 레이어의 구조를 단순화함.
//   1. 프리젠테이션 레이어 (V / C) - 웹 브라우저를 통해 사용자의 입력을 받아, 비즈니스 레이어에 전달 및 처리결과를 다시 브라우저에 표시
//   2. 비즈니스 레이어 - 필요에 따라 퍼시스턴스 레이어에를 통해 DB 작업처리 결과를 전달받으며, 이를 반환받아 비즈니스 로직을 작성
//   3. 퍼시스턴스 레이어 (M) - 비즈니스 레이어와 DB를 중개하기 위한 레이어.

// * REST 아키텍쳐 스타일 - 클라이언트(브라우저)가 서비스를 이용하려면, 어떤 형식으로 요청을 보내고 응답을 받는지
//   이러한 아키텍쳐 스타일로 설계 및 구현된 서비스를 Restful Service라고 한다.
//   1. 클라이언트-서버 : 리소스를 관리하는 서버가 존재하고, 다수의 클라이언트가 네트워크를 통해 서버에 접근하는 구조.
//   2. 상태가 없음 : 클라이언트가 서버에 요청을 보낼 때, 이전 요청의 영향을 받지 않음을 의미.
//      로그인 -> 다음페이지로 이동하는 경우는 서버가 이전 상태를 알고있어야 하므로 '상태가 있는' 아키텍쳐.
//      그러므로, 상태가 없는 아키텍쳐는 서버에 요청을 하기위해 필요한 모든 데이터를 포함해야 한다
//   3. 캐시되는 데이터 : 서버에서 리소스를 리턴 시, 캐시가 가능한지 여부를 명시할수 있어야 함.
//   4. 일관적인 인터페이스 : 리소스를 요청하기 위한 URI 일관성 혹은, 리턴타입의 일관성(+충분한 정보)과 같이,
//      URI 요청 응답, 요청형식 응답형식이 일관적이어야 한다.
//   5. 레이어 시스템 : 클라이언트가 서버에 요청할 때, 여러개의 레이어로 된 서버를 거칠수 있으나, 레이어들은 요청응답에
//      영향을 미치지 않으며 레이어 존재 유무도 몰라야 한다.
//   6. 코드온디멘트 : 클라이언트는 서버에 코드를 요청하며, 리턴코드를 실행할 수 있다.
//      REST(아케텍쳐)와 HTTP(프로토콜)는 다르더라도, REST를 구현할 때, HTTP를 사용하면 구현이 용이.
// GET : 주로 리소스를 가져오기 위함
// POST : 리소스에 대한 임의의 작업 수행(생성, 수정) 수행 시
// PUT : 리소스를 대체할 때 사용
// DELETE : 리소스를 삭제할 때 사용

// * 호스트는 네트워크에 연결하기 위하여 네트워크에 연결된 컴퓨터 혹은 그 외의 장치를 의미
// * 노드는 네트워크상에 존재하는 모든 장치를 의미
// 즉 네트워크를 이용하기 위해 주소가 할당된 노드 = 호스트

// * 클라이언트는 네트워크 상 요청하는 호스트를 의미
// * 서버는 요청에 응답할 수 있는 호스트로서, 요청하는 장치는 호스트, 요청에 응답하는 장치는 서버가 된다.
// 서버란 지정된 포트에 소켓을 열고, 클라이언트가 연결할 때 까지 무한 대기하며 기다리는 프로그램.
// 이후 클라이언트가 연결되면, 해당 클라이언트 소켓에서 요청을 받아와 수행 이후 응답을 작성해 연결함.
// 어떤 프로토콜을 사용하느냐에 따라 FTP 서버 혹은 HTTP 서버 등이 될 수 있다.

// 정적 웹 서버란 HTTP 서버 중에서 리소스 파일을 리턴하는 서버로서, 해당 파일을 별도로 처리하지 않고 있는 그대로 리턴함.
// Apache or Nginx 가 있다.

// 동적 웹 서버는 파일을 있는 그대로 리턴하는 대신, 요청을 처리한 후, 응답바디를 재구성 하거나 템플릿 파일에 결과를 대체하여 보냄.
// 이러한 작업을 스프링은 서블릿이 도와주어 소켓프로그래밍, HTTP 파싱, 스레드 풀 관리등을 수행한다.

// 기본적으로 HTTP 프로토콜 환경은 connectionless, stateless 특정을 가지므로, 클라이언트가 누구인지 항상 확인해야 한다.
// * connectionless
// 클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어 버리는 특징
// HTTP는 먼저 클라이언트가 request를 서버에 보내면, 서버는 클라이언트에게 요청에 맞는 response를 보내고 접속을 끊는 특성이 있다.
// 헤더에 keep-alive라는 값을 줘서 커넥션을 재활용하는데 HTTP1.1에서는 이것이 디폴트다.
// HTTP가 tcp위에서 구현되었기 때문에 (tcp는 연결지향,udp는 비연결지향) 네트워크 관점에서 keep-alive는 옵션으로 connectionless의 연결비용을 줄이는 것을 장점으로 비연결지향이라 한다.
// * stateless
// 통신이 끝나면 상태를 유지하지 않는 특징
// 연결을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특성이 있다.
// 쿠키와 세션은 위의 두 가지 특징을 해결하기 위해 사용합니다.
// 예를 들어, 쿠키와 세션을 사용하지 않으면 쇼핑몰에서 옷을 구매하려고 로그인을 했음에도, 페이지를 이동할 때 마다 계속 로그인을 해야 합니다.
// 쿠키와 세션을 사용했을 경우, 한 번 로그인을 하면 어떠한 방식에 의해서 그 사용자에 대한 인증을 유지하게 됩니다.

// * 쿠키
// 쿠키는 클라이언트 로컬에 저장되는 키와 값이 들어있는 작은 데이터파일
// 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있음
// 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조합니다.
// 클라이언트에 300개까지 쿠키저장 가능, 하나의 도메인당 20개의 값만 가질 수 있음, 하나의 쿠키값은 4KB까지 저장합니다.
// Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있음
// 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송

// * 세션
// 세션은 쿠키를 기반하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리합니다.
// 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지합니다.
// 물론 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능 합니다.
// 사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 됩니다.
// 즉 동접자 수가 많은 웹 사이트인 경우 서버에 과부하를 주게 되므로 성능 저하의 요인이 됩니다.
// 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는 데 이것이 세션 ID입니다.

// * 쿠키과 세션이 차이
// 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷합니다. 그 이유는 세션도 결국 쿠키를 사용하기 때문입니다.
// 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다.
// 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠릅니다. 그 이유는 세션은 서버의 처리가 필요하기 때문입니다.
// 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만 세션은 쿠키를 이용해서 sessionid 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋습니다.
// 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있습니다.
// 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제됩니다. 예를 들어, 크롬에서 다른 탭을 사용해도 세션을 공유됩니다. 다른 브라우저를 사용하게 되면 다른 세션을 사용할 수 있습니다.
// 속도, 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 가집니다.

// * 프로세스와 스레드의 차이
// 프로그램 = 어떤 작업을 위해 실행할 수 있는 파일. 주로 HDD나 SSD에 저장
// 프로세스란 CPU에 의해 실행되거나 실행준비중 상태에 들어가는 프로그램
// 1.연속적으로 실행되는 컴퓨터 프로그램 2. 메모리에 올라와 실행되고 있는 프로그램의 독립적인 개체 3. 운영체제로 부터 시스템자원을 할당받는 단위
// 하나의 프로세스는 독립된 메모리 영역 영억으로 구성.
//   - 코드 : 프로그램의 코드 자체 (실행되기 전 CPU가 해석할수 있는 바이너리 코드 상태로 주기억장치에 저장)
//   - 데이터 : 프로그램의 전역 or 정적변수 할당을 위해 존재하는 공간
//   - 스택 : 지역변수 할당 및 함수호출 시 전달한 argument값 저장
//   - 힙 : 동적할당(기억공간을 배정 및 회수)을 위하여 필요.
// 스레드 : 프로세스의 서로 독립적인 일을 순차적으로 수행하는 불필요함을 개선하기 위한 프로세스보다 작고 독립적으로 스케쥴링이 가능한 단위.
// 1. 각 스레드는 독립적이며, 실행/ 종료순서는 예측할 수 없다.
// 2. 스레드는 프로그램 외부에서는 보이지 않으며, 프로그램의 스레드 수는 다른 스레드에 알려지지 않는다.
// 3. 스레드는 프로세스의 일부분이기 때문에 프로세스의 자원들을 공유하지만, 그 자신의 처리시간과 스택, 레지스터들이 할당된다.
// 4. 스레드들은 독립적이나, 한 스레드가 취 행동은 다른 스레드에 영향을 미침 (한 스레드의 exit() 콜을 통하여 모든 스레드 종료 가능)
// 5. 스레드들은 수행을 위해 스케쥴되고, 결과들은 프로세스에 전달된다.